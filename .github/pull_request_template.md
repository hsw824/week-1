## 🧑‍💻 언어 및 제출 결과

- 사용 언어: `TypeScript`
- 통과 여부: ❌

## 🧠 풀이 설명

문제를 풀지 못했기 때문에 처음 접한 개념들을 적어보겠습니다.

문제의 요구사항은 이렇습니다.

- nums 배열에서 중복을 제거
- 반드시 추가 배열을 사용하지 말고, nums 자체를 수정(in-place) 해야 함

1. 제자리 알고리즘
   처음 문제를 읽었을 때, 생각한 답안은 이렇습니다.

```ts
function removeDuplicates(nums: number[]): number {
  const result: number[] = [];

  for (let num of nums) {
    const isAlreadyExist = result.includes(num);

    if (!isAlreadyExist) {
      result.push(num);
    }
  }

  return result.length;
}
```

답안을 확인했을 때 오류가 나와 문제를 다시 읽어봤을 때, in-place 알고리즘이라는 단어를 보고 검색을 해았습니다.
제자리(in-place) 알고리즘은 자료 구조를 추가로 사용하지 않고 입력을 변환하는 알고리즘이다이기 때문에 제가 작성한 코드처럼 새로운 배열을 만들지 않고 기존 배열 nums를 조작해야하는 문제였습니다.

회사에서 코드를 작성할 때 비슷한 상황에서는 메모리의 성능을 전혀 고려하지 않고, 새로운 배열을 만들어서 사용하거나 Set을 사용했었던것 같습니다. 그래서 제자리 알고리즘이라는 개념이 굉장히 생소했습니다.

2. 투 포인터

투 포인터는 두 개의 인덱스를 사용해서 리스트를 탐색하는 방식을 말합니다.

투포인터를 사용하는 예시에는

1. 중복 제거 – 정렬된 배열에서 유일한 값만 남길 때
2. 두 수의 합 – 정렬된 배열에서 합이 특정 값이 되는 두 수 찾기
3. 슬라이딩 윈도우 – 연속된 부분 배열의 조건 만족 여부 판단

가 있다고 합니다.

투 포인터의 장점은

- 추가 메모리가 필요하지 않음
- 불필요한 반복을 제거하고 시간 복잡도가 개선됨

투 포인터를 적용한 답안입니다.

```ts
function removeDuplicates(nums: number[]): number {
  if (nums.length === 0) return 0;

  let i = 0;

  for (let j = 1; j < nums.length; j++) {
    if (nums[j] !== nums[i]) {
      i++;
      nums[i] = nums[j];
    }
  }

  return i + 1;
}
```

## 📊 시간/공간 복잡도

- 시간 복잡도: `O(n)`
- 공간 복잡도: `O(1)`

## 📝 추가 설명 (선택)

- 고민했던 포인트가 있다면 간단히 적어주세요.

## 🙋‍♂️ 리뷰어에게

- 리뷰어가 보면 좋을 포인트, 질문, 궁금한 점 등을 작성해 주세요.

1. 문제를 제대로 풀지 못해서 질문할게 없네요ㅎ..
